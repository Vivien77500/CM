<!doctype html>
<html lang="fr" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Invaders</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Courier New', monospace;
      background: linear-gradient(to bottom, #0a0e27 0%, #1a1a3e 50%, #0a0e27 100%);
      overflow: hidden;
    }

    .game-wrapper {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .game-header {
      position: absolute;
      top: 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 40px;
      z-index: 10;
    }

    .score-display {
      color: #00ff88;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 10px #00ff88;
    }

    .lives-display {
      color: #ff3366;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 10px #ff3366;
    }

    #gameCanvas {
      background: rgba(10, 14, 39, 0.3);
      border: 3px solid #00ff88;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
      max-width: 90%;
      max-height: 90%;
    }

    .menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 14, 39, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .menu-overlay.hidden {
      display: none;
    }

    .game-title {
      color: #00ff88;
      font-size: 64px;
      font-weight: bold;
      text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
      margin-bottom: 20px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .start-button {
      background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
      color: #0a0e27;
      border: none;
      padding: 20px 60px;
      font-size: 28px;
      font-weight: bold;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
      transition: all 0.3s ease;
      font-family: 'Courier New', monospace;
    }

    .start-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 30px rgba(0, 255, 136, 0.6);
    }

    .start-button:active {
      transform: translateY(-1px);
    }

    .game-over-screen {
      text-align: center;
    }

    .game-over-title {
      color: #ff3366;
      font-size: 72px;
      font-weight: bold;
      text-shadow: 0 0 20px #ff3366, 0 0 40px #ff3366;
      margin-bottom: 20px;
      animation: flash 1s infinite;
    }

    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .final-score {
      color: #00ff88;
      font-size: 36px;
      margin-bottom: 30px;
    }

    .controls-info {
      color: #ffffff;
      font-size: 18px;
      margin-top: 40px;
      opacity: 0.8;
    }

    .choose-character-title {
      color: #00ccff;
      font-size: 32px;
      font-weight: bold;
      text-shadow: 0 0 15px #00ccff;
      margin-bottom: 40px;
    }

    .character-selection {
      display: flex;
      gap: 40px;
      margin-bottom: 30px;
    }

    .character-card {
      background: rgba(0, 255, 136, 0.1);
      border: 3px solid #00ff88;
      border-radius: 15px;
      padding: 20px;
      width: 180px;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .character-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 10px 40px rgba(0, 255, 136, 0.5);
      border-color: #00ffcc;
    }

    .character-image-container {
      width: 140px;
      height: 140px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;
      background: transparent;
      border-radius: 10px;
      overflow: hidden;
    }

    .character-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      mix-blend-mode: screen;
    }

    .character-name {
      color: #ffffff;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 15px;
    }

    .select-button {
      background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
      color: #0a0e27;
      border: none;
      padding: 10px 30px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Courier New', monospace;
    }

    .select-button:hover {
      background: linear-gradient(135deg, #00ffcc 0%, #00ff88 100%);
      transform: scale(1.05);
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body class="h-full">
  <div class="game-wrapper h-full w-full">
   <div class="game-header">
    <div class="score-display">
     SCORE: <span id="scoreValue">0</span>
    </div>
    <div class="lives-display">
     VIES: <span id="livesValue">3</span>
    </div>
    <div class="super-shot-display" style="color: #ffaa00; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #ffaa00;">
     SUPER TIR: <span id="superShotValue">0</span>/10
    </div>
    <div class="mega-shot-display" style="color: #ff00ff; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #ff00ff;">
     MEGA TIR: <span id="megaShotValue">0</span>/2500
    </div>
   </div>
   <canvas id="gameCanvas" width="1400" height="900"></canvas>
   <div id="difficultySelect" class="menu-overlay">
    <h1 class="game-title" id="gameTitle">SPACE INVADERS</h1>
    <h2 class="choose-character-title">CHOISISSEZ LA DIFFICULT√â</h2>
    <div class="character-selection">
     <div class="character-card" data-difficulty="facile">
      <div class="character-image-container" style="font-size: 64px;">
       üòä
      </div>
      <div class="character-name">
       FACILE
      </div><button class="select-button">CHOISIR</button>
     </div>
     <div class="character-card" data-difficulty="moyen">
      <div class="character-image-container" style="font-size: 64px;">
       üòê
      </div>
      <div class="character-name">
       MOYEN
      </div><button class="select-button">CHOISIR</button>
     </div>
     <div class="character-card" data-difficulty="difficile">
      <div class="character-image-container" style="font-size: 64px;">
       üò∞
      </div>
      <div class="character-name">
       DIFFICILE
      </div><button class="select-button">CHOISIR</button>
     </div>
     <div class="character-card" data-difficulty="extreme">
      <div class="character-image-container" style="font-size: 64px;">
       üíÄ
      </div>
      <div class="character-name">
       EXTR√äME
      </div><button class="select-button">CHOISIR</button>
     </div>
    </div>
   </div>
   <div id="characterSelect" class="menu-overlay hidden">
    <h1 class="game-title">SPACE INVADERS</h1>
    <h2 class="choose-character-title" id="chooseCharacterText">CHOISISSEZ VOTRE PERSONNAGE</h2>
    <div class="character-selection">
     <div class="character-card" data-character="flavio">
      <div class="character-image-container"><img src="https://raw.githubusercontent.com/Vivien77500/Invaders-family/main/Design%20sans%20titre(9).png" alt="Flavio" class="character-image">
      </div>
      <div class="character-name">
       FLAVIO
      </div><button class="select-button">CHOISIR</button>
     </div>
     <div class="character-card" data-character="mahdi">
      <div class="character-image-container"><img src="https://raw.githubusercontent.com/Vivien77500/Invaders-family/main/Design%20sans%20titre(11).png" alt="Mahdi" class="character-image">
      </div>
      <div class="character-name">
       MAHDI
      </div><button class="select-button">CHOISIR</button>
     </div>
     <div class="character-card" data-character="tiago">
      <div class="character-image-container"><img src="https://raw.githubusercontent.com/Vivien77500/Invaders-family/main/Design%20sans%20titre(10).png" alt="Tiago" class="character-image">
      </div>
      <div class="character-name">
       TIAGO
      </div><button class="select-button">CHOISIR</button>
     </div>
    </div>
    <div class="controls-info">
     Souris pour bouger | Clic gauche pour tirer | ESPACE pour SUPER TIR (10 touches) | D pour MEGA TIR (2500 points)
    </div>
   </div>
   <div id="gameOverMenu" class="menu-overlay hidden">
    <div class="game-over-screen">
     <h1 class="game-over-title" id="gameOverText">GAME OVER</h1>
     <div class="final-score">
      Score Final: <span id="finalScore">0</span>
     </div><button class="start-button" id="restartButton">REJOUER</button>
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "SPACE INVADERS",
      start_button: "D√âMARRER",
      game_over_text: "GAME OVER",
      choose_character: "CHOISISSEZ VOTRE PERSONNAGE"
    };

    const characters = {
      flavio: {
        name: "Flavio",
        image: "https://raw.githubusercontent.com/Vivien77500/Invaders-family/main/Design%20sans%20titre(9).png"
      },
      mahdi: {
        name: "Mahdi",
        image: "https://raw.githubusercontent.com/Vivien77500/Invaders-family/main/Design%20sans%20titre(11).png"
      },
      tiago: {
        name: "Tiago",
        image: "https://raw.githubusercontent.com/Vivien77500/Invaders-family/main/Design%20sans%20titre(10).png"
      }
    };

    let selectedCharacter = null;
    let selectedDifficulty = null;

    const difficultySettings = {
      facile: {
        lives: 3,
        enemySpeed: 0.8,
        enemyShootChance: 0.0005,
        speedIncrease: 0.3,
        pointMultiplier: 1
      },
      moyen: {
        lives: 3,
        enemySpeed: 1,
        enemyShootChance: 0.001,
        speedIncrease: 0.5,
        pointMultiplier: 1.5
      },
      difficile: {
        lives: 3,
        enemySpeed: 1.3,
        enemyShootChance: 0.0015,
        speedIncrease: 0.7,
        pointMultiplier: 2
      },
      extreme: {
        lives: 3,
        enemySpeed: 1.8,
        enemyShootChance: 0.002,
        speedIncrease: 1,
        pointMultiplier: 3
      }
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let gameState = {
      running: false,
      score: 0,
      totalScore: 0,
      lives: 3,
      player: null,
      enemies: [],
      bullets: [],
      enemyBullets: [],
      homingMissiles: [],
      explosions: [],
      keys: {},
      mouseX: null,
      enemyDirection: 1,
      enemySpeed: 1,
      lastEnemyShot: 0,
      hitCount: 0,
      superShotReady: false,
      megaShotScore: 0,
      megaShotReady: false
    };

    class Player {
      constructor(characterKey) {
        this.width = 70;
        this.height = 70;
        this.x = canvas.width / 2 - this.width / 2;
        this.y = canvas.height - 120;
        this.speed = 6;
        this.characterKey = characterKey;
        this.invincible = false;
        this.invincibleTimer = 0;
        this.blinkTimer = 0;
        this.auraPhase = 0;
      }

      draw() {
        const centerX = this.x + this.width / 2;
        const centerY = this.y + this.height / 2;
        
        if (gameState.megaShotReady) {
          this.auraPhase += 0.1;
          
          // Aura violette mega
          for (let i = 0; i < 4; i++) {
            const radius = 50 + i * 20 + Math.sin(this.auraPhase + i) * 15;
            const alpha = 0.4 - i * 0.1;
            
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, `rgba(255, 0, 255, ${alpha})`);
            gradient.addColorStop(0.5, `rgba(200, 0, 255, ${alpha * 0.6})`);
            gradient.addColorStop(1, `rgba(255, 0, 255, 0)`);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();
          }
          
          // √âclairs violets
          for (let i = 0; i < 12; i++) {
            const angle = (this.auraPhase * 2 + i * Math.PI / 6) % (Math.PI * 2);
            const distance = 60 + Math.sin(this.auraPhase * 3 + i) * 10;
            const sparkX = centerX + Math.cos(angle) * distance;
            const sparkY = centerY + Math.sin(angle) * distance;
            
            ctx.save();
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#ff00ff';
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
          }
        } else if (gameState.superShotReady) {
          this.auraPhase += 0.08;
          
          // Aura dor√©e super
          for (let i = 0; i < 3; i++) {
            const radius = 40 + i * 15 + Math.sin(this.auraPhase + i) * 10;
            const alpha = 0.3 - i * 0.1;
            
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, `rgba(255, 215, 0, ${alpha})`);
            gradient.addColorStop(0.5, `rgba(255, 170, 0, ${alpha * 0.6})`);
            gradient.addColorStop(1, `rgba(255, 215, 0, 0)`);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();
          }
          
          for (let i = 0; i < 8; i++) {
            const angle = (this.auraPhase + i * Math.PI / 4) % (Math.PI * 2);
            const distance = 50;
            const sparkX = centerX + Math.cos(angle) * distance;
            const sparkY = centerY + Math.sin(angle) * distance;
            
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffd700';
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
          }
        }
        
        if (this.invincible) {
          this.blinkTimer++;
          if (Math.floor(this.blinkTimer / 10) % 2 === 0) {
            return;
          }
        }
        
        if (!this.image) {
          this.image = new Image();
          this.image.src = characters[this.characterKey].image;
          this.image.onerror = () => {
            this.image = null;
            this.useFallback = true;
          };
        }
        
        if (this.image && this.image.complete && !this.useFallback) {
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
          ctx.restore();
        } else if (this.useFallback) {
          ctx.save();
          ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
          ctx.fillStyle = '#00ff88';
          ctx.beginPath();
          ctx.moveTo(0, -20);
          ctx.lineTo(-20, 15);
          ctx.lineTo(-10, 10);
          ctx.lineTo(-10, 20);
          ctx.lineTo(10, 20);
          ctx.lineTo(10, 10);
          ctx.lineTo(20, 15);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#00ccff';
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
      
      update() {
        if (this.invincible) {
          this.invincibleTimer--;
          if (this.invincibleTimer <= 0) {
            this.invincible = false;
            this.blinkTimer = 0;
          }
        }
      }
      
      hit() {
        if (this.invincible) return false;
        this.invincible = true;
        this.invincibleTimer = 180;
        this.blinkTimer = 0;
        return true;
      }

      move() {
        // Mouvement avec les fl√®ches (optionnel)
        if (gameState.keys['ArrowLeft'] && this.x > 0) {
          this.x -= this.speed;
        }
        if (gameState.keys['ArrowRight'] && this.x < canvas.width - this.width) {
          this.x += this.speed;
        }
        
        // Mouvement avec la souris
        if (gameState.mouseX !== null) {
          this.x = gameState.mouseX - this.width / 2;
          
          // Limiter dans les bordures
          if (this.x < 0) this.x = 0;
          if (this.x > canvas.width - this.width) {
            this.x = canvas.width - this.width;
          }
        }
      }

      shoot() {
        gameState.bullets.push(new Bullet(this.x + this.width / 2, this.y));
      }
    }

    class Enemy {
      constructor(x, y, type, characterKey) {
        this.width = 60;
        this.height = 60;
        this.x = x;
        this.y = y;
        this.type = type;
        this.characterKey = characterKey;
        this.animFrame = 0;
        this.velocityX = (Math.random() - 0.5) * 2;
        this.velocityY = Math.random() * 0.5 + 0.3;
        this.changeDirectionTimer = Math.random() * 100 + 50;
        this.originalX = x;
        this.originalY = y;
      }

      draw() {
        if (!this.image) {
          this.image = new Image();
          this.image.src = characters[this.characterKey].image;
          this.image.onerror = () => {
            this.image = null;
            this.useFallback = true;
          };
        }
        
        if (this.image && this.image.complete && !this.useFallback) {
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
          ctx.restore();
        } else if (this.useFallback) {
          ctx.save();
          ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
          
          if (this.type === 1) {
            ctx.fillStyle = '#ff3366';
            ctx.fillRect(-15, -10, 30, 20);
            ctx.fillStyle = '#ff5588';
            ctx.fillRect(-18, -8, 5, 15);
            ctx.fillRect(-8, -8, 5, 15);
            ctx.fillRect(3, -8, 5, 15);
            ctx.fillRect(13, -8, 5, 15);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-10, -5, 5, 5);
            ctx.fillRect(5, -5, 5, 5);
          } else {
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(-12, -8, 24, 16);
            ctx.fillStyle = '#ff8800';
            ctx.fillRect(-18, -3, 6, 3);
            ctx.fillRect(-18, 3, 6, 3);
            ctx.fillRect(12, -3, 6, 3);
            ctx.fillRect(12, 3, 6, 3);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-8, -3, 4, 4);
            ctx.fillRect(4, -3, 4, 4);
          }
          
          ctx.restore();
        }
      }

      move() {
        this.changeDirectionTimer--;
        
        if (this.changeDirectionTimer <= 0) {
          this.velocityX = (Math.random() - 0.5) * 3;
          this.velocityY = Math.random() * 0.5 + 0.3;
          this.changeDirectionTimer = Math.random() * 100 + 50;
        }
        
        this.x += this.velocityX * gameState.enemySpeed;
        this.y += this.velocityY * gameState.enemySpeed;
        
        if (this.x <= 0 || this.x + this.width >= canvas.width) {
          this.velocityX *= -1;
        }
        
        if (this.y < 50) {
          this.velocityY = Math.abs(this.velocityY);
        }
        
        const maxY = canvas.height * 0.6;
        if (this.y > maxY) {
          this.y = maxY;
          this.velocityY = -Math.abs(this.velocityY);
        }
      }

      canShoot() {
        const difficulty = difficultySettings[selectedDifficulty];
        return Math.random() < difficulty.enemyShootChance;
      }

      shoot() {
        gameState.enemyBullets.push(new EnemyBullet(this.x + this.width / 2, this.y + this.height));
      }
    }

    class Bullet {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 15;
        this.speed = 7;
      }

      draw() {
        ctx.fillStyle = '#00ff88';
        ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00ff88';
        ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
      }

      move() {
        this.y -= this.speed;
      }

      isOffScreen() {
        return this.y < 0;
      }
    }

    class EnemyBullet {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 15;
        this.speed = 4;
      }

      draw() {
        ctx.fillStyle = '#ff3366';
        ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff3366';
        ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
      }

      move() {
        this.y += this.speed;
      }

      isOffScreen() {
        return this.y > canvas.height;
      }
    }

    class HomingMissile {
      constructor(x, y, isMega = false) {
        this.x = x;
        this.y = y;
        this.width = 16;
        this.height = 35;
        this.speed = 5;
        this.turnSpeed = 0.15;
        this.target = null;
        this.trail = [];
        this.curveOffset = (Math.random() - 0.5) * 2;
        this.isMega = isMega;
        this.hasSplit = false;
        this.birthTime = Date.now();
      }

      findTarget() {
        if (gameState.enemies.length === 0) return null;
        
        let closest = null;
        let minDist = Infinity;
        
        for (let enemy of gameState.enemies) {
          const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
          if (dist < minDist) {
            minDist = dist;
            closest = enemy;
          }
        }
        
        return closest;
      }

      draw() {
        // Tra√Æn√©e de fum√©e
        const smokeColor = this.isMega ? '#ff00ff' : '#888888';
        const smokeShadow = this.isMega ? '#cc00cc' : '#666666';
        
        for (let i = 0; i < this.trail.length; i++) {
          const t = this.trail[i];
          const alpha = (1 - i / this.trail.length) * 0.5;
          const size = (1 - i / this.trail.length) * (this.isMega ? 10 : 8);
          
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = smokeColor;
          ctx.shadowBlur = this.isMega ? 12 : 8;
          ctx.shadowColor = smokeShadow;
          ctx.beginPath();
          ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Corps du missile
        ctx.fillStyle = this.isMega ? '#ff00ff' : '#ffaa00';
        ctx.beginPath();
        ctx.moveTo(0, -17);
        ctx.lineTo(-8, 17);
        ctx.lineTo(8, 17);
        ctx.closePath();
        ctx.fill();
        
        // Flammes
        ctx.fillStyle = this.isMega ? '#cc00ff' : '#ff6600';
        ctx.beginPath();
        ctx.moveTo(-4, 17);
        ctx.lineTo(-6, 25);
        ctx.lineTo(-2, 21);
        ctx.lineTo(2, 21);
        ctx.lineTo(6, 25);
        ctx.lineTo(4, 17);
        ctx.closePath();
        ctx.fill();
        
        // Centre lumineux
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.isMega ? '#ff00ff' : '#ffaa00';
        ctx.fillStyle = this.isMega ? '#ffccff' : '#ffff00';
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.restore();
      }

      move() {
        // Ajouter la position actuelle √† la tra√Æn√©e
        this.trail.unshift({ x: this.x, y: this.y });
        if (this.trail.length > 15) {
          this.trail.pop();
        }
        
        // V√©rifier si le missile mega doit se s√©parer (apr√®s 1 seconde)
        const timeElapsed = Date.now() - this.birthTime;
        
        if (this.isMega && !this.hasSplit && timeElapsed >= 1000) {
          this.hasSplit = true;
          this.split();
        }
        
        if (!this.target || gameState.enemies.indexOf(this.target) === -1) {
          this.target = this.findTarget();
        }
        
        if (this.target) {
          const dx = this.target.x + this.target.width / 2 - this.x;
          const dy = this.target.y + this.target.height / 2 - this.y;
          const angle = Math.atan2(dy, dx);
          
          // Ajout de la courbe sur le c√¥t√©
          this.x += Math.cos(angle) * this.speed + this.curveOffset;
          this.y += Math.sin(angle) * this.speed;
        } else {
          this.y -= this.speed;
        }
      }
      
      split() {
        // Cr√©er 1 missile suppl√©mentaire (total 2 avec celui-ci)
        const availableEnemies = gameState.enemies.filter(e => e !== this.target);
        
        if (availableEnemies.length > 0) {
          const newMissile = new HomingMissile(this.x, this.y, false);
          newMissile.target = availableEnemies[0];
          newMissile.curveOffset = (Math.random() - 0.5) * 3;
          gameState.homingMissiles.push(newMissile);
        }
      }

      isOffScreen() {
        return this.y < -50 || this.x < -50 || this.x > canvas.width + 50;
      }
    }

    class Explosion {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.particles = [];
        this.maxAge = 30;
        this.age = 0;
        
        // Cr√©er 25 particules pour une explosion plus spectaculaire
        for (let i = 0; i < 25; i++) {
          const angle = (Math.PI * 2 * i) / 25;
          const speed = Math.random() * 4 + 2;
          this.particles.push({
            x: this.x,
            y: this.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 5 + 2,
            color: Math.random() > 0.5 ? '#ff6600' : '#ffaa00'
          });
        }
      }
      
      draw() {
        for (let p of this.particles) {
          const alpha = 1 - (this.age / this.maxAge);
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;
          ctx.shadowBlur = 15;
          ctx.shadowColor = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
      
      update() {
        this.age++;
        for (let p of this.particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.95;
          p.vy *= 0.95;
        }
      }
      
      isDead() {
        return this.age >= this.maxAge;
      }
    }

    function createEnemies() {
      gameState.enemies = [];
      const rows = 4;
      const cols = 10;
      const spacing = 80;
      const startX = 120;
      const startY = 80;

      const enemyCharacters = Object.keys(characters).filter(key => key !== selectedCharacter);

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const type = row < 2 ? 1 : 2;
          const enemyChar = enemyCharacters[type - 1];
          gameState.enemies.push(
            new Enemy(startX + col * spacing, startY + row * spacing, type, enemyChar)
          );
        }
      }
    }

    function checkCollision(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }

    function updateGame() {
      if (!gameState.running) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      gameState.player.move();
      gameState.player.update();
      gameState.player.draw();

      for (let enemy of gameState.enemies) {
        enemy.move();
        enemy.draw();
        
        if (enemy.canShoot()) {
          enemy.shoot();
        }
      }

      // Afficher les explosions
      for (let i = gameState.explosions.length - 1; i >= 0; i--) {
        const explosion = gameState.explosions[i];
        explosion.update();
        explosion.draw();
        
        if (explosion.isDead()) {
          gameState.explosions.splice(i, 1);
        }
      }

      for (let i = gameState.bullets.length - 1; i >= 0; i--) {
        const bullet = gameState.bullets[i];
        bullet.move();
        bullet.draw();

        if (bullet.isOffScreen()) {
          gameState.bullets.splice(i, 1);
          continue;
        }

        for (let j = gameState.enemies.length - 1; j >= 0; j--) {
          const enemy = gameState.enemies[j];
          if (checkCollision(bullet, enemy)) {
            gameState.enemies.splice(j, 1);
            gameState.bullets.splice(i, 1);
            const difficulty = difficultySettings[selectedDifficulty];
            const basePoints = enemy.type === 1 ? 20 : 10;
            gameState.score += Math.floor(basePoints * difficulty.pointMultiplier);
            gameState.hitCount++;
            updateScore();
            updateSuperShot();
            break;
          }
        }
      }

      for (let i = gameState.homingMissiles.length - 1; i >= 0; i--) {
        const missile = gameState.homingMissiles[i];
        missile.move();
        missile.draw();

        if (missile.isOffScreen()) {
          gameState.homingMissiles.splice(i, 1);
          continue;
        }

        for (let j = gameState.enemies.length - 1; j >= 0; j--) {
          const enemy = gameState.enemies[j];
          const missileRect = {
            x: missile.x - missile.width / 2,
            y: missile.y - missile.height / 2,
            width: missile.width,
            height: missile.height
          };
          if (checkCollision(missileRect, enemy)) {
            // Cr√©er une explosion √† l'impact
            gameState.explosions.push(new Explosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2));
            gameState.enemies.splice(j, 1);
            gameState.homingMissiles.splice(i, 1);
            const difficulty = difficultySettings[selectedDifficulty];
            const basePoints = (enemy.type === 1 ? 20 : 10) * 2;
            gameState.score += Math.floor(basePoints * difficulty.pointMultiplier);
            updateScore();
            break;
          }
        }
      }

      for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
        const bullet = gameState.enemyBullets[i];
        bullet.move();
        bullet.draw();

        if (bullet.isOffScreen()) {
          gameState.enemyBullets.splice(i, 1);
          continue;
        }

        if (checkCollision(bullet, gameState.player)) {
          gameState.enemyBullets.splice(i, 1);
          
          if (gameState.player.hit()) {
            gameState.lives--;
            updateLives();
            
            if (gameState.lives <= 0) {
              endGame();
              return;
            }
          }
        }
      }

      if (gameState.enemies.length === 0) {
        createEnemies();
        const difficulty = difficultySettings[selectedDifficulty];
        gameState.enemySpeed += difficulty.speedIncrease;
      }

      requestAnimationFrame(updateGame);
    }

    function updateScore() {
      gameState.totalScore = gameState.score;
      document.getElementById('scoreValue').textContent = gameState.totalScore;
      updateMegaShot();
    }
    
    function updateMegaShot() {
      const display = document.getElementById('megaShotValue');
      const currentProgress = gameState.totalScore % 2500;
      gameState.megaShotScore = currentProgress;
      display.textContent = currentProgress;
      
      if (currentProgress === 0 && gameState.totalScore > 0 && !gameState.megaShotReady) {
        gameState.megaShotReady = true;
        gameState.superShotReady = false;
        gameState.hitCount = 0;
        document.getElementById('superShotValue').textContent = '0';
        document.getElementById('superShotValue').parentElement.style.color = '#ffaa00';
        document.getElementById('superShotValue').parentElement.style.textShadow = '0 0 10px #ffaa00';
        display.parentElement.style.color = '#00ff00';
        display.parentElement.style.textShadow = '0 0 20px #00ff00';
      } else if (gameState.totalScore >= 2500 && currentProgress >= 2500) {
        // Premier palier de 2500 atteint
        gameState.megaShotReady = true;
        gameState.superShotReady = false;
        gameState.hitCount = 0;
        document.getElementById('superShotValue').textContent = '0';
        document.getElementById('superShotValue').parentElement.style.color = '#ffaa00';
        document.getElementById('superShotValue').parentElement.style.textShadow = '0 0 10px #ffaa00';
        display.parentElement.style.color = '#00ff00';
        display.parentElement.style.textShadow = '0 0 20px #00ff00';
      }
    }

    function updateLives() {
      document.getElementById('livesValue').textContent = gameState.lives;
    }

    function updateSuperShot() {
      const display = document.getElementById('superShotValue');
      display.textContent = Math.min(gameState.hitCount, 10);
      
      if (gameState.hitCount >= 10 && !gameState.superShotReady && !gameState.megaShotReady) {
        gameState.superShotReady = true;
        display.parentElement.style.color = '#00ff00';
        display.parentElement.style.textShadow = '0 0 20px #00ff00';
      }
    }

    function fireSuperShot() {
      if (!gameState.superShotReady || gameState.megaShotReady) return;
      
      const startX = gameState.player.x + gameState.player.width / 2;
      const startY = gameState.player.y;
      
      // S√©lectionner 5 cibles diff√©rentes
      const targets = gameState.enemies.slice(0, 5);
      
      // Cr√©er 5 missiles, chacun avec sa propre cible
      for (let i = 0; i < targets.length; i++) {
        const missile = new HomingMissile(startX, startY, false);
        missile.target = targets[i];
        gameState.homingMissiles.push(missile);
      }
      
      gameState.hitCount = 0;
      gameState.superShotReady = false;
      const display = document.getElementById('superShotValue');
      display.textContent = '0';
      display.parentElement.style.color = '#ffaa00';
      display.parentElement.style.textShadow = '0 0 10px #ffaa00';
    }
    
    function fireMegaShot() {
      if (!gameState.megaShotReady) return;
      
      const startX = gameState.player.x + gameState.player.width / 2;
      const startY = gameState.player.y;
      
      // S√©lectionner 3 cibles diff√©rentes pour les 3 missiles initiaux
      const targets = gameState.enemies.slice(0, 3);
      
      // Cr√©er 3 missiles MEGA, chacun avec sa propre cible
      for (let i = 0; i < targets.length; i++) {
        const missile = new HomingMissile(startX, startY, true);
        missile.target = targets[i];
        gameState.homingMissiles.push(missile);
      }
      
      gameState.megaShotReady = false;
      const display = document.getElementById('megaShotValue');
      display.textContent = '0';
      display.parentElement.style.color = '#ff00ff';
      display.parentElement.style.textShadow = '0 0 10px #ff00ff';
    }

    function startGame() {
      if (!selectedCharacter || !selectedDifficulty) return;
      
      const difficulty = difficultySettings[selectedDifficulty];
      
      gameState.running = true;
      gameState.score = gameState.totalScore;
      gameState.lives = difficulty.lives;
      gameState.bullets = [];
      gameState.enemyBullets = [];
      gameState.homingMissiles = [];
      gameState.explosions = [];
      gameState.enemyDirection = 1;
      gameState.enemySpeed = difficulty.enemySpeed;
      gameState.hitCount = 0;
      gameState.superShotReady = false;
      gameState.megaShotScore = gameState.totalScore % 2500;
      gameState.megaShotReady = (gameState.totalScore % 2500 === 0 && gameState.totalScore > 0) || (gameState.totalScore >= 2500 && gameState.totalScore % 2500 >= 0);
      
      gameState.player = new Player(selectedCharacter);
      createEnemies();
      
      updateScore();
      updateLives();
      updateSuperShot();
      updateMegaShot();
      
      document.getElementById('difficultySelect').classList.add('hidden');
      document.getElementById('characterSelect').classList.add('hidden');
      document.getElementById('gameOverMenu').classList.add('hidden');
      
      requestAnimationFrame(updateGame);
    }
    
    function resetGame() {
      gameState.totalScore = 0;
      gameState.score = 0;
      selectedCharacter = null;
      selectedDifficulty = null;
      document.getElementById('difficultySelect').classList.remove('hidden');
      document.getElementById('characterSelect').classList.add('hidden');
      document.getElementById('gameOverMenu').classList.add('hidden');
    }

    function endGame() {
      gameState.running = false;
      document.getElementById('finalScore').textContent = gameState.totalScore;
      document.getElementById('gameOverMenu').classList.remove('hidden');
    }

    // Gestion de la souris
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      gameState.mouseX = e.clientX - rect.left;
    });
    
    canvas.addEventListener('mouseleave', () => {
      gameState.mouseX = null;
    });
    
    canvas.addEventListener('click', (e) => {
      if (gameState.running && gameState.player) {
        gameState.player.shoot();
      }
    });

    document.addEventListener('keydown', (e) => {
      gameState.keys[e.key] = true;
      
      if (e.key === ' ' && gameState.running) {
        e.preventDefault();
        fireSuperShot();
      }
      
      if ((e.key === 's' || e.key === 'S') && gameState.running) {
        e.preventDefault();
        fireSuperShot();
      }
      
      if ((e.key === 'd' || e.key === 'D') && gameState.running) {
        e.preventDefault();
        fireMegaShot();
      }
    });

    document.addEventListener('keyup', (e) => {
      gameState.keys[e.key] = false;
    });

    document.getElementById('difficultySelect').querySelectorAll('.select-button').forEach(button => {
      button.addEventListener('click', (e) => {
        const card = e.target.closest('.character-card');
        selectedDifficulty = card.dataset.difficulty;
        document.getElementById('difficultySelect').classList.add('hidden');
        document.getElementById('characterSelect').classList.remove('hidden');
      });
    });

    document.getElementById('characterSelect').querySelectorAll('.select-button').forEach(button => {
      button.addEventListener('click', (e) => {
        const card = e.target.closest('.character-card');
        selectedCharacter = card.dataset.character;
        startGame();
      });
    });

    document.getElementById('restartButton').addEventListener('click', () => {
      resetGame();
    });

    async function onConfigChange(config) {
      document.getElementById('gameTitle').textContent = config.game_title || defaultConfig.game_title;
      document.getElementById('chooseCharacterText').textContent = config.choose_character || defaultConfig.choose_character;
      document.getElementById('restartButton').textContent = config.start_button || defaultConfig.start_button;
      document.getElementById('gameOverText').textContent = config.game_over_text || defaultConfig.game_over_text;
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities: (config) => ({
          recolorables: [],
          borderables: [],
          fontEditable: undefined,
          fontSizeable: undefined
        }),
        mapToEditPanelValues: (config) => new Map([
          ["game_title", config.game_title || defaultConfig.game_title],
          ["start_button", config.start_button || defaultConfig.start_button],
          ["game_over_text", config.game_over_text || defaultConfig.game_over_text],
          ["choose_character", config.choose_character || defaultConfig.choose_character]
        ])
      });
    }
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9b00f6efd7f7f6a9',t:'MTc2NjA4NTA3MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>